DWORD WINAPI DllAttach(HMODULE Base) {
	HANDLE hPipe = CreateNamedPipe(TEXT("\\\\.\\pipe\\pipe_name"), PIPE_ACCESS_DUPLEX,
		PIPE_TYPE_BYTE | PIPE_READMODE_BYTE, 1, 1024 * 16, 1024 * 16, 0, NULL);

	if (hPipe == INVALID_HANDLE_VALUE)
	{		
		return 0;
	}

	char buffer[MAX_PATH];
	DWORD dwRead;	
	while (hPipe != INVALID_HANDLE_VALUE)
	{				
		if (ConnectNamedPipe(hPipe, NULL) != FALSE)  
		{			
			while (ReadFile(hPipe, buffer, sizeof(buffer) - 1, &dwRead, NULL) != FALSE)
			{
				/* add terminating zero */
				buffer[dwRead] = '\0';

				Sleep(1000);

        /* can use other file deletion methods */
				if (std::remove(buffer) != 0)
				{
					MessageBoxA(nullptr, "Error deleting file", "Error", 0);
				}
			}
		}
		DisconnectNamedPipe(hPipe);
	}	
	FreeLibraryAndExitThread(Base, 0);
	return 0;
}

DWORD WINAPI DllDetach() {

	return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved
)
{
	if (ul_reason_for_call == DLL_PROCESS_ATTACH)
	{
		DisableThreadLibraryCalls(hModule);
		CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)DllAttach, hModule, NULL, NULL);
	}
	else if (ul_reason_for_call == DLL_PROCESS_DETACH)
	{

		DllDetach();
	}
	return TRUE;	
}
